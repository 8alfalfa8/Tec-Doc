# ◆ 正規表現（Regular Expression）について

## 【正規表現とは？】
「文字列のパターンを表現するための言語」 です。
一定の規則（パターン）に従った表現方法を使って、ファイルやテキストを効率的に検索・操作する技術です。

---

## 【２つの主要な正規化パターン】

### 1. **ワイルドカード（シェルグロブ）** - `find` コマンドで主に使用
ファイル名を検索するときに使う、シンプルなパターン

| 記号 | 意味 | 例 | 実際に探すもの |
|------|------|----|----------------|
| `*` | **0文字以上の任意の文字列** | `*.log` | `.log`で終わるファイル（例: `app.log`, `error.log`, `2024.log`） |
| `?` | **ちょうど1文字** | `file?.txt` | `file1.txt`, `fileA.txt`, `file_.txt`（`file.txt`は×） |
| `[ ]` | **指定した文字のどれか1文字** | `file[123].log` | `file1.log`, `file2.log`, `file3.log` |

**実例（findコマンド）**：
```bash
# 全てのログファイルを探す
find /var/log -name "*.log"

# 2024年のログファイル（2024で始まる）
find . -name "2024*.log"

# server1.log, server2.log, server3.log を探す
find . -name "server[123].log"

# backup1.txt, backup2.txt, ... backup9.txt を探す
find /backup -name "backup?.txt"
```

---

### 2. **正規表現（regex）** - `grep` コマンドで主に使用
テキスト内容を検索するときに使う、より強力なパターン

| 記号 | 意味 | 例 | 実際に探すもの |
|------|------|----|----------------|
| `.` | **任意の1文字** | `er.or` | `error`, `erior`, `er@or`（er + 何か1文字 + or） |
| `*` | **直前の文字が0回以上繰り返す** | `ab*c` | `ac`, `abc`, `abbc`, `abbbc`... |
| `[ ]` | **指定した文字のどれか1文字** | `[aeiou]` | 母音（a, e, i, o, u）のどれか |
| `^` | **行の先頭** | `^ERROR` | 行の最初が"ERROR"で始まる |
| `$` | **行の末尾** | `\.log$` | 行の最後が".log"で終わる |
| `\` | **特別な文字を通常の文字として扱う** | `file\.txt` | `file.txt`（.を特殊な意味ではなく、ドットとして扱う） |

**実例（grepコマンド）**：
```bash
# ERRORかWARNINGを含む行を探す
grep "ERROR\|WARNING" app.log

# "ERROR"で始まる行を探す
grep "^ERROR" app.log

# 数字3桁-数字2桁-数字2桁のパターン（日付）を探す
grep "[0-9]\{3\}-[0-9]\{2\}-[0-9]\{2\}" data.txt

# IPアドレスのパターンを探す（192.168.1.1など）
grep "[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+" access.log
```

---

## 【実務でよく使う組み合わせ例】

### シナリオ1：監視ログから緊急アラートを抽出
```bash
# 方法1: 複数のキーワードを一度に検索
grep -E "CRITICAL|FATAL|EMERGENCY" /var/log/messages

# 方法2: 今日の日付（2024-02-06）で始まる行からエラーを探す
grep "^2024-02-06.*ERROR" application.log
```

### シナリオ2：古いバックアップファイルを一括検索
```bash
# 2023年のバックアップファイルをすべて探す
find /backup -name "*2023*.tar.gz"

# 1月から3月までのログファイルを探す
find /var/log -name "*2024-0[1-3]*.log"
```

### シナリオ3：設定ファイル内の特定パターンを検索
```bash
# IPアドレスをコメントアウトしていない行から探す
grep "^[^#]*[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+" config.txt

# パスワード設定を検索（password, passwd, pwdなど）
grep -i "pass" /etc/*.conf
```

---

## 【覚え方のコツ】

### 絵文字で理解する
```
find の *  : "何でもいいよ〜" 😊
         例: *.log = "名前は何でもいいけど、最後が.logならOK"

grep の .  : "誰か1人" 👤
         例: a.b = "a + 誰か1人 + b"

grep の *  : "0回以上おかわりOK" 🔁
         例: ab*c = "a + (bが0回以上) + c"

^ : "最初から" 🏁
$ : "最後まで" 🏁
```

### 実際のファイルで練習
```bash
# 練習用ファイル作成
echo -e "ERROR: Disk full\nWARNING: Memory low\nINFO: Backup started\nERROR: Connection failed" > test.log

# ERRORを含む行を探す
grep "ERROR" test.log

# Eで始まりDで終わる単語を探す
grep "E.*D" test.log
```

---

## 【よくある間違いと解決策】

### 問題1：ドット（.）が特殊文字として扱われる
```bash
# ✗ 間違い: file.txtを探そうとして...
grep "file.txt" *.log
# これは "file + 何か1文字 + txt" も検索してしまう

# ○ 正しい: ドットをエスケープする
grep "file\.txt" *.log
```

### 問題2：スペースを含むファイル名
```bash
# ✗ 間違い
find . -name *.log file.txt

# ○ 正しい: クォートで囲む
find . -name "*.log file.txt"
```

### 問題3：大文字小文字を区別しない検索
```bash
# 大文字小文字を区別しない
grep -i "error" app.log
# → "ERROR", "Error", "error" すべて検索
```

---

## 【監視業務での実践パターン集】

```bash
# 1. 今日のエラーログを抽出
TODAY=$(date +%Y-%m-%d)
grep "^${TODAY}.*ERROR" /var/log/app.log > today_errors.txt

# 2. 特定時間帯のログを抽出（9時から17時まで）
grep "^.* 0[9-1][0-9]:[0-5][0-9]:[0-5][0-9]" access.log

# 3. バックアップファイル（拡張子が.bak, .backup, .oldのもの）を探す
find /data -name "*\.bak" -o -name "*\.backup" -o -name "*\.old"

# 4. 空でないログファイルを探す
find /var/log -name "*.log" -size +0

# 5. 直近1時間に更新されたファイルを探す
find . -name "*.log" -mmin -60
```

---

## 【まとめ表】

| 目的 | 使うもの | 例 | 意味 |
|------|----------|----|------|
| **ファイル名**を検索 | ワイルドカード | `*.log` | 何でもいい + `.log` |
| **テキスト内容**を検索 | 正規表現 | `^ERROR` | 行頭がERROR |
| 1文字の違い | `?` または `.` | `file?.txt` | ファイル名の?部分は1文字 |
| 複数文字の違い | `*` | `backup*.tar.gz` | *部分は何文字でもOK |
| 選択肢の中から | `[ ]` | `[aeiou]` | a,e,i,o,uのどれか |

**最も重要なポイント**：
- `find` でファイルを探す → **ワイルドカード**を使う
- `grep` で中身を探す → **正規表現**を使う
- 分からなくなったら → **バックスラッシュ（\）でエスケープ**

この理解があれば、監視ログから必要な情報を素早く抽出できるようになります！

---
---

# ◆ 正規表現（Regular Expression）完全ガイド

---

## 【基本メタ文字一覧表】

### 1. **位置を表すメタ文字**
| 記号 | 名前 | 意味 | 例 | マッチ例 | 非マッチ例 |
|------|------|------|----|----------|------------|
| `^` | キャレット | **行の先頭** | `^ERROR` | `ERROR: disk full` | `This is ERROR` |
| `$` | ドル | **行の末尾** | `\.log$` | `app.log` | `app.log.bak` |
| `\b` | 単語境界 | **単語の区切り** | `\berror\b` | `error occurred` | `errors occurred` |

### 2. **文字の種類を表すメタ文字**
| 記号 | 意味 | 同等表現 | 例 | マッチ例 |
|------|------|----------|----|----------|
| `.` | **任意の1文字**（改行除く） | - | `a.c` | `abc`, `a@c`, `a c` |
| `\d` | **数字1文字** | `[0-9]` | `\d\d` | `42`, `01` |
| `\D` | **数字以外の1文字** | `[^0-9]` | `\D\D` | `ab`, `@#` |
| `\w` | **単語構成文字**（英数字＋アンダースコア） | `[a-zA-Z0-9_]` | `\w+` | `hello`, `user_123` |
| `\W` | **非単語構成文字** | `[^\w]` | `\W` | `@`, `-`, ` ` |
| `\s` | **空白文字**（スペース、タブ、改行） | `[ \t\n\r]` | `\s+` | ` `, `\t\t` |
| `\S` | **非空白文字** | `[^\s]` | `\S+` | `hello`, `a+b` |

### 3. **繰り返しを表すメタ文字**
| 記号 | 意味 | 例 | マッチ例 | 説明 |
|------|------|----|----------|------|
| `*` | **0回以上** | `a*` | ``, `a`, `aa`, `aaa` | なくてもOK |
| `+` | **1回以上** | `a+` | `a`, `aa`, `aaa` | 最低1つ必要 |
| `?` | **0回または1回** | `colou?r` | `color`, `colour` | あってもなくてもOK |
| `{n}` | **ちょうどn回** | `\d{4}` | `2024`, `1234` | 4桁の数字 |
| `{n,}` | **n回以上** | `\d{3,}` | `123`, `1234` | 3桁以上 |
| `{n,m}` | **n回以上m回以下** | `\d{2,4}` | `12`, `123`, `1234` | 2-4桁 |

### 4. **選択・グループ化**
| 記号 | 意味 | 例 | マッチ例 |
|------|------|----|----------|
| `[ ]` | **文字クラス**（どれか1文字） | `[aeiou]` | `a`, `e`, `i`, `o`, `u` |
| `[^ ]` | **否定文字クラス** | `[^0-9]` | `a`, `@`, ` `（数字以外） |
| `( )` | **グループ化**（まとめて扱う） | `(abc)+` | `abc`, `abcabc` |
| `(a|b)` | **選択**（aまたはb） | `(error|warning)` | `error`, `warning` |
| `|` | **OR演算子** | `cat|dog` | `cat`, `dog` |

---

## 【エスケープの必要性】
**特別な意味を持つ文字を通常の文字として検索したいとき**

```bash
# 間違い: . が「任意の1文字」として扱われる
grep "file.txt" logfile  # file1txt などもマッチしてしまう

# 正しい: \ でエスケープ
grep "file\.txt" logfile  # file.txt のみマッチ

# エスケープが必要な主な文字
# . * + ? { } [ ] ( ) ^ $ | \ /
```

---

## 【実践例：監視ログ解析】

### 例1: IPアドレスの抽出
```bash
# IPv4アドレスのパターン
grep -E "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" access.log

# 分解:
# \b           : 単語境界（単語の始まり）
# [0-9]{1,3}   : 1-3桁の数字
# \.           : ドット（.をエスケープ）
# {3}          : 上記のパターンを3回繰り返す
# [0-9]{1,3}   : 1-3桁の数字
# \b           : 単語境界（単語の終わり）
```

### 例2: タイムスタンプの抽出
```bash
# 形式: 2024-02-06 14:30:45
grep -E "\b[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}\b" app.log

# より正確な時間（00-23時、00-59分、00-59秒）
grep -E "\b[0-9]{4}-[01][0-9]-[0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9]\b" app.log
```

### 例3: エラーレベルの抽出
```bash
# ERROR, WARNING, INFO のいずれか
grep -E "(ERROR|WARNING|INFO)" system.log

# 大文字小文字を区別しない
grep -i "error\|warning\|info" system.log

# CRITICAL または FATAL（行の先頭にある場合）
grep "^CRITICAL\|^FATAL" alert.log
```

### 例4: メールアドレスの抽出
```bash
grep -E "\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b" user_data.txt

# 分解:
# [a-zA-Z0-9._%+-]+  : ユーザー名部分（1文字以上）
# @                  : @マーク
# [a-zA-Z0-9.-]+     : ドメイン名部分
# \.                 : ドット
# [a-zA-Z]{2,}       : トップレベルドメイン（2文字以上）
```

---

## 【便利な応用例】

### 1. **ログのフィルタリング**
```bash
# 今日の9時から18時までのログだけ抽出
grep -E "^2024-02-06 (09|1[0-8]):[0-5][0-9]:[0-5][0-9]" app.log

# 数字を含む行だけ抽出
grep "[0-9]" logfile

# 数字だけの行を抽出（文字が含まれない）
grep "^[0-9]+$" data.txt
```

### 2. **データの整形**
```bash
# カンマ区切りファイルの3列目だけ抽出
grep -oE "^([^,]+,){2}[^,]+" data.csv

# ログから日付部分だけ抽出
grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" app.log

# URLの抽出
grep -oE "https?://[a-zA-Z0-9./?=_%&:-]+" web_log.txt
```

### 3. **エラーパターンの検出**
```bash
# ディスク使用率が90%以上の行を検出
grep -E "disk.*([9][0-9]|100)%" system.log

# メモリ使用率が危険水準の行
grep -E "memory.*([8-9][0-9]|100)%" system.log

# 接続エラー（connect, connection, timeoutなど）
grep -i "connect.*(fail|error|timeout|refused)" network.log
```

---

## 【覚え方のコツ：イメージで覚える】

### 絵文字メモリ法
```
^  : 「最初から！」🏁（スタートライン）
$  : 「最後まで！」🏁（ゴールライン）
.  : 「誰か一人」👤（どんな人でもOK）
*  : 「0回以上おかわり自由」🔄（無限ループ）
+  : 「1回以上は必須」👍（最低1回）
?  : 「あってもなくても」🤷（オプション）
\d : 「数字さん」🔢（digitのd）
\w : 「単語くん」📝（wordのw）
\s : 「スペース君」␣（spaceのs）
```

### 実際のログで練習
```bash
# 練習用ログ作成
cat > practice.log << 'EOF'
2024-02-06 09:15:23 INFO: System started
2024-02-06 09:16:45 ERROR: Disk usage 95%
2024-02-06 10:30:12 WARNING: Memory low
2024-02-06 11:45:33 INFO: Backup completed
2024-02-06 14:20:15 ERROR: Connection timeout
EOF

# 練習問題
grep "ERROR" practice.log              # ERRORを含む行
grep "^2024-02-06 1[0-9]:" practice.log # 10時台から19時台
grep -E "[0-9]+%" practice.log         # パーセント表記のある行
```

---

## 【よくある間違いと正解】

### 問題1: ドットのエスケープ忘れ
```bash
# ✗ 間違い
grep "192.168.1.1" logfile
# 192x168y1z1 などもマッチ！

# ○ 正解
grep "192\.168\.1\.1" logfile
```

### 問題2: アスタリスクの意味の誤解
```bash
# ✗ 間違い: "abc" という文字列を探そうとして
grep "abc*"
# これは ab, abc, abcc, abccc... すべてマッチ！

# ○ 正解
grep "abc"
```

### 問題3: 括弧のエスケープ忘れ
```bash
# ✗ 間違い
grep "(ERROR|WARNING)"
# 正規表現エンジンによってはエラー

# ○ 正解（基本正規表現の場合）
grep "\(ERROR\|WARNING\)"

# ○ 正解（拡張正規表現の場合）
grep -E "(ERROR|WARNING)"
```

---

## 【拡張正規表現モード】
`grep -E` または `egrep` を使うと、エスケープが減って書きやすくなります。

```bash
# 基本正規表現（たくさんエスケープ）
grep "\(ERROR\|WARNING\)" file.log

# 拡張正規表現（エスケープ少ない）
grep -E "(ERROR|WARNING)" file.log

# 拡張正規表現での便利機能
grep -E "ERROR{2,}"    # ERRORが2回以上連続
grep -E "(abc)+"       # abcが1回以上繰り返し
```

---

## 【監視業務での実践パターン集】

### 安全なパスワードの検出
```bash
# 8文字以上、大文字小文字数字を含む
grep -E "^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$" password_file.txt
```

### ログローテーションされたファイルの検索
```bash
# ログファイル（.log, .log.1, .log.2.gz など）
find /var/log -name "*.log*" | grep -E "\.log(\.[0-9]+(\.gz)?)?$"
```

### 不正アクセスの検出
```bash
# 短時間での複数回失敗ログイン
grep "Failed password" auth.log | grep -E "from ([0-9]{1,3}\.){3}[0-9]{1,3}" | sort
```

### システムリソースの閾値監視
```bash
# CPU使用率が90%超え
grep -E "CPU.*([9][0-9]|100)%" metrics.log

# ディスク空き容量が10%以下
grep -E "disk.*free.*([0-9]|10)%" storage.log
```

---

## 【練習問題と解答】

### 問題1: 電話番号（03-1234-5678形式）を抽出
```bash
# 解答
grep -E "\b0[0-9]-[0-9]{4}-[0-9]{4}\b" contacts.txt
```

### 問題2: HTMLタグの中身を抽出
```bash
# <title>Welcome</title> から "Welcome" を抽出
grep -oE "<title>(.*?)</title>" webpage.html | sed 's/<[^>]*>//g'
```

### 問題3: クレジットカード番号（仮想）を検出
```bash
# 16桁の数字（4-4-4-4形式）
grep -E "\b[0-9]{4}-[0-9]{4}-[0-9]{4}-[0-9]{4}\b" data.txt
```

---

## 【参考：正規表現ビジュアライザー】

理解を深めるためのツール：
1. **[regex101.com](https://regex101.com/)** - オンライン正規表現テスター
2. **debuggex.com** - 正規表現を図解
3. **rubular.com** - シンプルなテスト環境

---

## 【最終チェックリスト】

✅ 位置指定（`^`, `$`, `\b`）を理解した<br>
✅ 文字クラス（`\d`, `\w`, `\s`, `.`）を使い分けられる<br>
✅ 繰り返し（`*`, `+`, `?`, `{n,m}`）を適切に使える<br>
✅ グループ化（`( )`）と選択（`|`）ができる<br>
✅ エスケープ（`\`）の必要性を理解した<br>
✅ `grep -E` で拡張正規表現が使える<br>

**最も重要な心得**：
> 「正規表現は書いた本人ですら翌日には理解できないことがある」  
> だからこそ、シンプルに、コメントを残して、テストしながら作りましょう。

監視業務では、このスキルでログの海から「必要な情報の針」を素早く見つけられるようになります！
