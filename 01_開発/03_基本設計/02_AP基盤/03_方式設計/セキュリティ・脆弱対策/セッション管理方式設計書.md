# ◆ セッション管理方式設計書
---

## 1. 目的

Webアプリケーションにおけるセッション管理の方式・ポリシーを定義する。
ユーザー認証状態の安全かつスケーラブルな管理、セキュリティ（XSS/CSRF/セッション固定/再利用による侵害など）対策、運用（監査・ログ・切断）を保証することを目的とする。

---

## 2. 適用範囲

* Webフロントエンド（ブラウザ）とバックエンドAPI間の認証・認可セッション管理
* 単一ページアプリ（SPA）および従来のサーバーサイドレンダリング（SSR）を含む
* シングルサインオン（SSO）やモバイルクライアントとの連携を含む（要件に応じて）

---

## 3. 設計方針（高レベル）

1. **最小権限・短寿命**：必要最小限の権限を付与し、有効期間は短くする（リスク軽減）。
2. **サーバー側制御を第一**：セッション失効やログアウトを即時反映できるよう、可能ならサーバー側で状態を管理する。
3. **クッキーを第一選択（ブラウザ）**：ブラウザ利用時はセキュア属性付きのクッキーを用いる。SPAではアクセストークン+HttpOnlyリフレッシュトークン方式（ハイブリッド）を推奨。
4. **防御層の重複**：CSRFトークン、SameSite、Content Security Policy等を組み合わせる。
5. **スケーラビリティ**：ステートフルな場合は共有ストア（Redis等）を用いる。
6. **監査・観測**：セッション作成/破棄/異常検出のログを出力し、インシデント時に追跡可能にする。

---

## 4. 脅威モデル（代表）

* **XSS** によりクッキー/ローカルストレージ内トークンを盗まれる
* **CSRF** により有効セッションを悪用される
* **セッション固定（session fixation）** による乗っ取り
* **リプレイ攻撃**：盗まれたトークンの再使用
* **横方向移動**：権限のないユーザーがトークンでアクセス
* **スケール／運用上の漏れ**：リフレッシュトークンの失効管理ができない

---

## 5. 推奨アーキテクチャ（方式） — 要約

* **ブラウザ（一般）**：短寿命アクセス用 JWT またはセッションIDを `HttpOnly; Secure; SameSite=Strict/Lax` クッキーで保持。重要操作はCSRFトークンを要求。
* **SPA**：アクセストークン（短命、メモリ保持） + リフレッシュトークン（HttpOnlyクッキー）。アクセストークンは Authorization: Bearer ヘッダで送付。
* **API / モバイル**：OAuth2.0 標準に準拠（アクセストークン + リフレッシュトークン）。
* **サーバー側ストア**：状態管理が必要なら Redis 等で session store を保持（id → user, issued_at, last_active, device, ip, revocation_flag）。

---

## 6. セッションライフサイクル設計

### 6.1 発行（ログイン）

* 認証成功時にセッションを発行。
* 発行データ：

  * `session_id`（十分長いランダム値, 128-bit+ 推奨）または `access_token`（署名付きJWT）
  * `issued_at`, `expires_at`, `last_active_at`
  * `user_id`, `scopes/roles`（最小限）
  * `client_info`（user agent ハッシュ、ipハッシュ、device id）
* クッキー属性（ブラウザ用）：

  * `Set-Cookie: session=<value>; HttpOnly; Secure; Path=/; SameSite=Strict`（または Lax）
  * `SameSite=Strict` はUXに影響するため、必要に応じて Lax を採用。外部リダイレクトが必要な場合は注意。

### 6.2 維持（リクエスト時）

* 認証：`session_id` もしくは `Authorization: Bearer <access_token>` を検証。
* サーバー側で状態管理する場合は、該当 `session_id` が有効で、`revoked=false` かつ `expires_at > now` を確認。
* アクセス時に `last_active_at` を更新（ただし DB/Redis 書き込み頻度を考慮し、必要に応じて更新間隔を制限）。

### 6.3 更新（リフレッシュ）

* アクセストークン（短命）→ リフレッシュトークン（長命）で更新。
* リフレッシュ時は **リプレイ防止** のためワンタイムリフレッシュ（トークン交換で旧リフレッシュ無効化）を推奨。
* リフレッシュ時に `iat`/`exp` のリセットと、新しい `session_id` 発行を検討（セッション固定対策）。

### 6.4 破棄（ログアウト / 失効）

* ログアウト時はサーバー上のセッションを `revoked=true` にする、または該当 session レコードを削除。
* リフレッシュトークンやアクセストークンの失効もサーバー側で追跡（ブラックリスト）する。
* 強制ログアウト（管理者操作）も可能にし、すべての端末セッションを無効化する API を用意。

---

## 7. トークン設計詳細

### 7.1 セッションID（サーバー状態管理）

* 生成：CSPRNGによりランダム生成（例：256-bit）→ Base64 / hex。
* 保管：Redis ハッシュ `session:{session_id}` → JSON（user_id, issued_at, expires_at, last_active, device_info, revoked）。
* TTL：`expires_at` により自動寿命管理（Redis TTL利用）。

### 7.2 JWT（ステートレス認証）設計（必要なら）

* 署名：`HS256`（共有鍵）または `RS256`（公開鍵）を使用。**RS256 推奨**（鍵管理容易）。
* Claims（最低限）：

  * `iss`（issuer）, `sub`（user id）, `aud`（audience）, `iat`, `exp`（短め、例：15分）
  * `jti`（JWT ID, 一意） — 追跡/失効に利用可能
  * `scp`/`roles`（必要最小限）
* リフレッシュ：JWT は短命にして、リフレッシュはサーバー側で管理する（ステートフル）。
* 失効：ステートレスでも `jti` をブラックリスト化することで失効管理可能（ただしブラックリストの運用コストあり）。

---

## 8. クッキー/保管のベストプラクティス

* `HttpOnly`：必須（JavaScriptから読めない）
* `Secure`：必須（HTTPSのみ）
* `SameSite`：原則 `Strict` または `Lax`。サードパーティ投稿や外部認証を使う場合は例外検討。
* `Domain`/`Path`：目的に応じて最小化（`Path=/` は一般的）。
* 長期トークン（リフレッシュ）は **必ず** `HttpOnly` クッキーに格納する。アクセストークンはメモリに保持（SPA）し、localStorageは XSS リスクで非推奨。
* Cookie の `Max-Age`/`Expires` は合理的に設定。

---

## 9. CSRF対策

* **State-changing**（POST/PUT/DELETE）エンドポイントにCSRFトークンを要求。
* CSRFトークンは `SameSite` と併用。
* SPA + `Authorization: Bearer` ヘッダ方式を使う場合、CSRFリスクは低いが、cookie-auth を使う場合は必須。
* `Double Submit Cookie` や `Synchronizer Token Pattern` を採用。

---

## 10. XSS対策

* CSP（Content-Security-Policy）を設定してスクリプトのインジェクションを防ぐ。
* 出力エスケープ、テンプレートの安全な利用、ライブラリのアップデート。
* `HttpOnly` を適切に利用し、クッキー盗難のリスクを下げる。

---

## 11. セッション固定（Fixation）対策

* 認証成功時にセッションIDを再生成（既存の ID を破棄し、新しい ID を発行）。
* ログイン前に任意の `session_id` を使わせない（予測困難なID設計）。

---

## 12. 多端末・多デバイス運用

* セッションをデバイス別に管理（`session_id` に device info を紐付け）。
* 管理画面で「全端末ログアウト」「特定端末の切断」を提供。
* アクティビティ（IP/UA）異常検出でチャレンジ（追加認証）を実施。

---

## 13. スケーラビリティと可用性

* **オプション A（ステートフル）**：Redis セッションストア。水平スケールの App Server は Redis を参照。

  * Redis クラスタ or マスター/レプリカで冗長化。
  * 書き込み頻度抑制（last_active の更新は閾値ベースで）。
* **オプション B（ステートレス）**：JWT のみ（ただし失効管理が難しい）。
* 負荷分散時は **Sticky Session を使わない** 設計を推奨（共有ストアで代替）。

---

## 14. 監査・ログ・モニタリング

* イベントログ：`session_created`, `session_refreshed`, `session_revoked`, `login_failed`, `logout` を記録。
* ログ内容：`timestamp`, `user_id`, `session_id/jti`, `ip`, `user_agent`, `action`, `result`。
* アラート：同一アカウントで短時間に多数のログイン試行や、異常地域からのアクセスを検出したら通知。
* ログ保管：監査要件に応じて保存期間を設定（例：90日、法的要件に従う）。

---

## 15. 運用（鍵管理・ローテーション）

* JWT 署名鍵（特に秘密鍵）は KMS（AWS KMS / GCP KMS）や Vault で管理。
* 鍵ローテーション：公開鍵方式の場合 `kid` ヘッダで鍵識別子を付与し、段階的ロールアウトで互換性を保つ。
* ローテーション時の影響：古いトークンの失効方針を明確にする（即時失効か自然失効か）。

---

## 16. 退避・失効（ログアウト、パスワード変更時）

* パスワード変更・重要権限変更時はすべての既存セッションを即時無効化。
* 失効リスト（ブラックリスト）を用意し、API でチェック（Redisなどで保持）。

---

## 17. API エンドポイント（例）

* `POST /auth/login`

  * 入力：`{username,password}`
  * 出力：`Set-Cookie: refresh_token`（HttpOnly） + `access_token`（レスポンス or メモリ）
* `POST /auth/refresh`

  * 入力：HttpOnly cookie（refresh_token）
  * 処理：refresh トークン検証 → 新アクセストークン発行 → 新 refresh トークン発行（旧を無効化）
* `POST /auth/logout`

  * 入力：HttpOnly cookie / Authorization ヘッダ
  * 処理：session を revoked にする / cookie を削除
* `GET /session/list`（管理用）

  * 出力：ユーザーのアクティブセッション一覧（device, ip, created_at, last_active）
* `POST /session/revoke`（管理用）

  * 入力：`{session_id}` → 対象セッションを失効

---

## 18. データモデル（例：Redis ハッシュ / DB テーブル）

### Redis（session:{id}）

```text
{
  "session_id": "abc...",
  "user_id": "u-123",
  "issued_at": "2025-11-08T03:00:00Z",
  "expires_at": "2025-11-08T03:15:00Z",
  "last_active_at": "2025-11-08T03:05:00Z",
  "device": "Chrome on Win",
  "ip": "1.2.3.4",
  "revoked": false,
  "jti": "jti-uuid"
}
```

### RDBMS テーブル（optional）

* `sessions`（id, user_id, issued_at, expires_at, last_active, device, ip_hash, revoked, created_by）

---

## 19. チェックリスト（設計→実装→テスト）

### 設計段階

* [ ] セッションタイプ（ステートフル/ステートレス）確定
* [ ] TTL（idle/absolute）定義
* [ ] リフレッシュポリシー定義（ワンタイム or リユース）
* [ ] 失効方式（ブラックリスト/DB フラグ）選定

### 実装段階

* [ ] CSPRNG を使った ID 生成
* [ ] HTTPS 強制（HSTS）
* [ ] Cookie 属性（HttpOnly, Secure, SameSite）実装
* [ ] CSRF トークン実装（該当するエンドポイント）
* [ ] 鍵（署名）管理とローテーション機構実装

### テスト段階

* [ ] XSS ペネトレーションテスト（トークン盗難）
* [ ] CSRF テスト（state-changing エンドポイント）
* [ ] セッション固定テスト（ログイン後 ID 再生成）
* [ ] リフレッシュフローのリプレイテスト（古いリフレッシュトークンが使えないこと）
* [ ] 負荷試験（Redis スループット、TTL 負荷）
* [ ] 多端末ログアウトの検証

---

## 20. 例：SPA 用推奨フロー（簡潔）

1. ユーザーが `/auth/login` にフォーム送信。
2. サーバーは認証成功で `access_token`（15分）をレスポンスボディに返す（JS側はメモリ保持）、`refresh_token`（14日）を `HttpOnly; Secure; SameSite=Strict` のクッキーで設定。
3. API 呼び出しは `Authorization: Bearer <access_token>`。
4. `access_token` 期限切れ → クライアントは `/auth/refresh` を呼ぶ（cookie 自動送付）。サーバーは新 access & refresh を返す。
5. ログアウト時は `/auth/logout` を呼び、サーバーで refresh を失効 & cookie をクリア。

---

## 21. 追加考慮点（業務要件に応じて）

* **法令・コンプライアンス**：個人情報保護法、ログ保存基準、GDPR 等の規制に従う。
* **長期セッション**：Remember-me 機能は別トークンで、二段階認証やリスクスコアリングと併用する。
* **多要素認証（MFA）**：高権限操作では必須化。MFA の状態もセッションに紐付ける。
* **SSO / OAuth2**：外部 IdP を使う場合は OpenID Connect を採用し、ID トークンの検証方法を明確にする。

---

## 22. 運用手順（インシデント時）

1. 異常検知（ログ/アラート）→ 疑わしい `session_id/jti` を即時無効化。
2. 影響ユーザーへ通知（必要に応じてパスワードリセットを促す）。
3. 監査ログ分析 → 侵害の範囲特定 → 対応報告と再発防止策実施。

---

## 23. 参考（実務的な値・推奨）

* Access token lifetime：10〜30 分
* Refresh token lifetime：7〜30 日（ただしワンタイム交換）
* Idle timeout（非操作時）：30分〜2時間（業務特性に応じて）
* Absolute timeout（強制ログアウト）：7〜90日（セキュリティポリシー次第）

> ※ 上記は一般的推奨値。実際は業務リスク・ユーザー体験・法規制に合わせて調整する。

---

## 24. 実装スニペット（概念・擬似コード）

```text
# pseudocode: login
if authenticate(username,password):
    session_id = generate_secure_id()
    store_redis("session:" + session_id, {user_id, issued_at, expires_at, device, ip})
    set_cookie("refresh_token", session_id, httpOnly=True, secure=True, samesite="Strict")
    access_token = sign_jwt({sub: user_id, iat, exp=now+15m})
    return {access_token}
```

---

## 25. まとめ（重要ポイント）

* **HttpOnly + Secure + SameSite を適切に利用**し、XSS/CSRF リスクを低減する。
* **アクセストークンは短命**にし、**リフレッシュはサーバー制御（ワンタイム）**で行う。
* **サーバー側状態（Redis）を用いた失効管理**が現実的で安全性が高い。
* **監査ログと運用手順**を整備して、インシデントに素早く対応できる体制を作る。

---
