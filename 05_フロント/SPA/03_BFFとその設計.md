# ◆ BFF（Backend For Frontend）とその設計

以下では、**BFF（Backend For Frontend）とその設計**について、
**概念 → なぜ必要か → 全体アーキテクチャ → 設計原則 → API設計 → 認証認可 → 非機能 → 実装方式 → 成果物 → 失敗例**
の順で、**業務系（金融・公共レベル）で実際に設計書として通用する深さ**まで詳しくご説明します。

---

## 1. BFFとは何か（本質）

### 1.1 定義

**BFF（Backend For Frontend）とは、特定のフロントエンド専用に最適化されたバックエンド層**です。

* フロント（SPA / Mobile）ごとに用意
* UI都合のデータ構造・粒度に最適化
* 内部APIや外部サービスを隠蔽

👉 **BFFは「UIのための翻訳・統合層」**

---

## 2. なぜBFFが必要なのか

### 2.1 BFFなしで起きる問題

| 問題     | 内容             |
| ------ | -------------- |
| API乱立  | 画面ごとに複数API呼び出し |
| 過取得/不足 | UIに合わないレスポンス   |
| 認証分散   | フロントで認証ロジック    |
| セキュリティ | Token管理がJS側に露出 |

---

### 2.2 BFF導入による解決

| 観点     | 効果          |
| ------ | ----------- |
| UX     | API回数削減     |
| 開発     | フロント都合で進化可能 |
| 保守     | マイクロサービス非依存 |
| セキュリティ | 認証集約        |

---

## 3. BFFを含む全体アーキテクチャ

```
[ Browser (SPA) ]
        |
        | HTTPS
        v
[ CDN / WAF ]
        |
        v
[      BFF      ]
        |
        | 内部API
        v
[ Backend Services ]
        |
        v
[ DB / 外部API ]
```

#### BFFの責務

* データ集約
* フィールド整形
* 認証・認可
* UI特化API

---

## 4. BFF設計原則（最重要）

### 原則① フロント専用

* 他クライアントから再利用しない
* UI変更に追随可能

### 原則② ビジネスロジックは持たない

❌ 業務計算
⭕ UI制御・集約

### 原則③ 疎結合

* 下位API変更を吸収
* バージョン依存を隠す

### 原則④ セキュリティ境界

* 認証・認可を集中管理

---

## 5. BFF API設計

### 5.1 API粒度（画面単位）

#### 例：ダッシュボード画面

```
GET /bff/dashboard
```

```json
{
  "user": {...},
  "notifications": [...],
  "statistics": {...}
}
```

👉 **1画面 = 1 API が基本**

---

### 5.2 命名規則

* `/bff/{page}/{action}`
* REST厳守より **可読性優先**

---

### 5.3 レスポンス設計指針

* UIがそのまま描画できる形
* nullを極力出さない
* フラット構造

---

## 6. 認証・認可設計（BFFの中核）

### 6.1 認証の責務

* Cookie（HttpOnly）認証
* Token検証
* セッション管理

```
[ SPA ]
   |
   | Cookie
   v
[ BFF ] ← 認証
   |
   v
[ Backend ]
```

---

### 6.2 認可（権限制御）

* ロール／権限チェック
* API単位のアクセス制御
* UI表示可否情報を返却

---

## 7. エラーハンドリング設計

### エラー種別

| 種類   | 例   |
| ---- | --- |
| 認証   | 401 |
| 認可   | 403 |
| 業務   | 4xx |
| システム | 5xx |

👉 **フロントが扱いやすい形に正規化**

---

## 8. 非機能設計（業務レベル）

### 8.1 パフォーマンス

* 並列API呼び出し
* キャッシュ（短期）

### 8.2 可用性

* タイムアウト
* フォールバック

### 8.3 セキュリティ

* 入力検証
* レート制限
* 監査ログ

---

## 9. 実装方式

### 9.1 技術選択

| 技術               | 用途       |
| ---------------- | -------- |
| Node.js (NestJS) | SPA向け    |
| FastAPI          | Python系  |
| Spring Boot      | エンタープライズ |

---

### 9.2 処理フロー例

```
Request
 ↓
Auth Check
 ↓
Permission Check
 ↓
Call APIs (Parallel)
 ↓
Assemble Response
 ↓
Return
```

---

## 10. GraphQL型BFF（発展）

### 特徴

* フロント主導
* オーバーフェッチ防止
* 型安全

### 注意

* 認可設計が難しい
* 金融系ではREST型が主流

---

## 11. 成果物（設計書）

* BFFアーキテクチャ図
* BFF責務定義書
* API設計書
* 認証認可設計書
* エラーハンドリング設計書
* 非機能設計書

---

## 12. よくある失敗例

| 失敗         | 問題       |
| ---------- | -------- |
| BFFが業務ロジック | 責務違反     |
| BFF乱立      | 保守不能     |
| フロント直API   | セキュリティ事故 |
| 巨大BFF      | モノリス化    |

---

## 13. BFFが向いているケース / 不要なケース

| ケース        | 評価 |
| ---------- | -- |
| SPA + 複雑画面 | ◎  |
| マイクロサービス   | ◎  |
| 小規模CRUD    | △  |
| 単一画面       | 不要 |

---

### まとめ（設計者視点）

* BFFはUIのための層
* APIは画面単位
* 認証・認可の要
* 業務ロジックは持たせない
* 設計書で責務を固定する

---

