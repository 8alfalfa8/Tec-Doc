# ◆ SPA（Single Page Application）における認証・認可設計

以下では、**SPA（Single Page Application）における認証・認可設計**について、
**概念整理 → 脅威モデル → 方式比較 → 推奨アーキテクチャ → 詳細設計（フロー／実装） → 非機能・運用 → 設計成果物 → 失敗例**
の順で、**金融・公共・大規模業務システムでそのまま設計書に使えるレベル**まで掘り下げて説明します。

---

## 1. 認証・認可の前提整理（最重要）

### 1.1 認証（Authentication）

> **「あなたは誰か」**

* ログイン
* セッション確立
* Token検証

### 1.2 認可（Authorization）

> **「あなたは何をしてよいか」**

* 画面表示可否
* API実行可否
* データ参照範囲

👉 **SPAではこの2つを明確に分離して設計する**

---

## 2. SPA特有の脅威モデル

### 2.1 SPAが抱えるリスク

| 脅威      | 説明           |
| ------- | ------------ |
| XSS     | JSからToken窃取  |
| CSRF    | Cookie悪用     |
| Token漏洩 | LocalStorage |
| 権限偽装    | クライアント改変     |
| API直叩き  | BFFなし        |

---

### 2.2 結論（業務系の原則）

> **「認証情報をJavaScriptに触らせない」**

---

## 3. 認証方式の比較

| 方式                    | 評価 | コメント   |
| --------------------- | -- | ------ |
| Session + Cookie      | ○  | スケール注意 |
| JWT + LocalStorage    | ❌  | XSSで即死 |
| JWT + HttpOnly Cookie | ◎  | 推奨     |
| OAuth2 / OIDC         | ◎  | IdP連携可 |

👉 **金融・公共では OIDC + Cookie が標準**

---

## 4. 推奨アーキテクチャ（結論）

```
[ Browser (SPA) ]
      |
      | HTTPS (Cookie)
      v
[    BFF    ]
      |
      v
[ Backend / IdP ]
```

#### 役割分担

| 層       | 役割      |
| ------- | ------- |
| SPA     | UI制御のみ  |
| BFF     | 認証・認可判断 |
| Backend | 業務ロジック  |
| IdP     | ユーザー管理  |

---

## 5. 認証設計（詳細）

### 5.1 ログインフロー（OIDC例）

```
① SPA → /login
② BFF → IdP リダイレクト
③ IdP 認証
④ 認可コード
⑤ BFF Token取得
⑥ HttpOnly Cookie保存
```

👉 **TokenはBFFでのみ保持**

---

### 5.2 Cookie設計（重要）

| 属性       | 設定           |
| -------- | ------------ |
| HttpOnly | true         |
| Secure   | true         |
| SameSite | Lax / Strict |
| Domain   | 最小範囲         |
| Path     | /            |

---

## 6. 認可設計（最重要）

### 6.1 認可は必ずサーバ側

❌ SPAのif文
⭕ BFF / APIで判定

---

### 6.2 認可モデル

#### ① RBAC（Role-Based）

* 管理者
* 一般ユーザー

#### ② ABAC（Attribute-Based）

* 所属
* 契約種別
* データ属性

👉 **業務系では RBAC + ABAC の併用**

---

### 6.3 認可粒度

| レベル | 制御対象  |
| --- | ----- |
| 画面  | 表示可否  |
| API | 実行可否  |
| データ | 行／列制御 |

---

### 6.4 フロントへの権限情報提供

```json
{
  "permissions": {
    "user.create": true,
    "user.delete": false
  }
}
```

👉 表示制御のため「ヒント」として渡す<br>
👉 **最終判断は必ずサーバ**

---

## 7. 画面遷移・ルーティング制御

### 7.1 認証ガード

* 未認証 → ログイン
* 認可不足 → 403画面

### 7.2 リロード耐性

* 初期ロード時に `/bff/me` 呼び出し
* セッション有無判定

---

## 8. API設計上の注意

| 項目  | 対応    |
| --- | ----- |
| 401 | 未認証   |
| 403 | 権限不足  |
| 404 | 存在隠蔽  |
| 429 | レート制限 |

---

## 9. 非機能・運用設計

### 9.1 セッション管理

* 有効期限
* 更新（Silent Refresh）
* 多重ログイン制御

### 9.2 監査ログ

* ログイン
* 権限エラー
* 管理操作

---

## 10. 実装パターン（概念）

#### BFF（FastAPI例）

```python
def auth_required(user=Depends(get_user)):
    if not user:
        raise HTTPException(401)
```

---

#### SPA（React）

```ts
if (!user) return <Navigate to="/login" />;
```

---

## 11. 成果物（設計書）

* 認証方式選定理由書
* 認証フロー図
* Cookie設計書
* 認可モデル定義書
* 権限制御マトリクス
* 監査ログ設計書

---

## 12. よくある失敗例

| 失敗         | 問題   |
| ---------- | ---- |
| TokenをJS保持 | XSS  |
| 権限制御をUI    | 改ざん  |
| API直呼び     | 認可漏れ |
| 403乱用      | 情報漏洩 |

---

## 13. 設計レビュー観点（抜粋）

* TokenはJSから不可視か
* 認可は全APIにあるか
* URL直打ち耐性
* ログアウト時の無効化

---

### まとめ（結論）

* SPAは「薄く」
* 認証・認可はBFF集中
* Cookie + OIDCが最適解
* UIはヒント、判断はサーバ
* 設計書で縛らないと事故る

---

# ◆ SPA × BFF × マルチテナント環境における認可設計

以下では、**SPA × BFF × マルチテナント環境における認可設計**について、
**概念 → テナントモデル → 認可レイヤ → 設計原則 → データ／API設計 → フロー → 実装指針 → 非機能 → 成果物 → 失敗例**
の順で、**金融・公共・SaaSでそのまま設計書に落とせるレベル**まで詳しく説明します。

---

## 1. マルチテナント認可とは（前提）

### 1.1 定義

**1つのアプリケーション基盤を複数の「テナント（組織・顧客）」が安全に共有し、
他テナントのデータ・操作を一切参照・操作できないようにする認可設計**

👉 認証より **認可の難易度が高い**

---

## 2. マルチテナントで守るべき境界

| 境界     | 説明       |
| ------ | -------- |
| テナント境界 | 他社データ遮断  |
| ロール境界  | 管理者 / 一般 |
| データ境界  | 行・列レベル   |
| 機能境界   | 契約プラン    |

👉 **境界が4層あるのが業務系の現実**

---

## 3. テナントモデルの種類（設計起点）

### 3.1 テナント分離方式（重要）

| 方式     | 概要         | 評価      |
| ------ | ---------- | ------- |
| DB分離   | テナント毎DB    | ◎（金融）   |
| スキーマ分離 | 1DB多Schema | ○       |
| 行分離    | tenant_id  | ◎（SaaS） |

👉 認可設計は **分離方式に強く依存**

---

### 3.2 推奨（一般SaaS）

* **行分離 + tenant_id**
* 物理分離は将来オプション

---

## 4. 認可モデル設計（中核）

### 4.1 三層認可モデル（推奨）

```
[ テナント認可 ]
      ↓
[ ロール認可 ]
      ↓
[ データスコープ認可 ]
```

---

#### ① テナント認可（最上位）

* 「このユーザーはこのテナントに属しているか」

```text
user.tenant_id === resource.tenant_id
```

👉 **全APIで必須**

---

#### ② ロール認可（機能）

| ロール         | 権限   |
| ----------- | ---- |
| TenantAdmin | 全機能  |
| Manager     | 一部管理 |
| User        | 参照のみ |

---

#### ③ データスコープ認可（ABAC）

* 所属部署
* 担当者
* 契約範囲

---

## 5. 認可情報の持ち方（設計の肝）

### 5.1 Token / セッションに含める情報

| 項目        | 理由    |
| --------- | ----- |
| tenant_id | 境界の根拠 |
| user_id   | 主体    |
| roles     | 機能判定  |
| scopes    | データ範囲 |

👉 **必要最小限のみ**

---

### 5.2 例（概念）

```json
{
  "sub": "user123",
  "tenant_id": "tenantA",
  "roles": ["manager"],
  "scopes": ["dept:10"]
}
```

---

## 6. API認可設計（必須）

### 6.1 全APIの基本チェック

```
① 認証
② tenant_id一致
③ ロールチェック
④ データスコープチェック
```

---

### 6.2 API設計例

#### ❌ 悪い例

```
GET /users/123
```

#### ⭕ 良い例

```
GET /tenants/{tenantId}/users/{id}
```

👉 **URIにテナントを含めると安全性が上がる**

---

## 7. データアクセス設計（超重要）

### 7.1 tenant_id強制付与

* INSERT時：必須
* SELECT時：必須
* UPDATE/DELETE：WHERE tenant_id

---

### 7.2 ORMレベル制御（推奨）

* グローバルフィルタ
* Repository共通条件

```sql
SELECT * FROM users
WHERE tenant_id = :tenant_id
```

👉 **開発者ミスを防ぐ**

---

## 8. BFFにおける役割

| 項目      | BFF     |
| ------- | ------- |
| テナント判定  | ◎       |
| ロール判定   | ◎       |
| データスコープ | △（ヒント）  |
| 最終保証    | Backend |

👉 **二重チェックが原則**

---

## 9. フロントエンド（SPA）の扱い

### 9.1 SPAは信頼しない

* tenant_idは表示用のみ
* 送信値は信用しない

### 9.2 表示制御

```json
{
  "permissions": {
    "user.create": true
  }
}
```

👉 UX向上用

---

## 10. クロステナント操作（例外設計）

### 10.1 システム管理者

* 別ロール
* 別API
* 別UI

👉 **通常APIと混ぜない**

---

## 11. 非機能設計

### 11.1 セキュリティ

* URL直叩き耐性
* ID推測耐性
* ログにtenant_id必須

### 11.2 監査

* 誰が
* どのテナントで
* 何をしたか

---

## 12. テスト設計（必須）

| テスト | 内容      |
| --- | ------- |
| 正常  | 同一テナント  |
| 異常  | 他テナントID |
| 境界  | ロール切替   |
| 負荷  | 大量テナント  |

---

## 13. 成果物（設計書）

* テナントモデル定義書
* 認可モデル図（3層）
* ロール権限定義表
* API認可一覧
* データアクセス設計書
* テナント分離方針書

---

## 14. よくある致命的失敗

| 失敗           | 結果       |
| ------------ | -------- |
| tenant_id未条件 | 情報漏洩     |
| SPA判定依存      | 改ざん      |
| 管理者API混在     | 全漏洩      |
| 手書きWHERE     | ヒューマンエラー |

---

## 15. 設計レビュー観点（抜粋）

* 全APIでtenantチェックしているか
* DBで強制できているか
* 管理者と一般が分離されているか
* ログにtenant_idがあるか

---

### まとめ（結論）

* マルチテナントは「認可が本体」
* tenant境界は最優先
* 認可は三層構造
* ORM・DBで強制
* 二重防御が正解

---
