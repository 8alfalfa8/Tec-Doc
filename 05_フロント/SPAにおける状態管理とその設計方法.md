# ◆ SPAにおける状態管理（State Management）とその設計方法

以下では、**SPAにおける状態管理（State Management）と、その設計方法**について、
**概念 → 種類分類 → 設計原則 → 設計手順 → 具体パターン → 実装例 → よくある失敗**
の順で、**業務システム（金融・公共レベル）で破綻しない設計粒度**まで踏み込んで詳しく説明します。

---

## 1. 状態管理とは何か（本質）

### 1.1 状態（State）の定義

**状態とは「画面やアプリの振る舞いを決定する、時間とともに変化するデータ」**です。

例：

* ログインユーザー
* 権限
* 検索条件
* フォーム入力中の値
* ローディング中か否か

👉 **SPAでは画面遷移＝状態変化**
👉 **状態管理＝アプリの設計そのもの**

---

## 2. なぜ状態管理設計が重要なのか

#### 状態管理が破綻すると起きること

* 画面更新されない
* どこで値が変わったかわからない
* リロードで壊れる
* バグ修正が不可能になる

👉 **状態管理はUI技術ではなく設計技術**

---

## 3. 状態の分類（最重要）

まず「状態を分類する」ことが設計の第一歩です。

### 3.1 状態の4分類（実務標準）

| 分類          | 内容    | 例           |
| ----------- | ----- | ----------- |
| ① グローバル状態   | アプリ全体 | ログインユーザー、権限 |
| ② 画面状態      | 画面単位  | 検索条件、ページ番号  |
| ③ コンポーネント状態 | 部品単位  | モーダル開閉      |
| ④ サーバ状態     | API由来 | 一覧データ       |

---

### 3.2 各状態の寿命（ライフサイクル）

| 状態      | 生存期間       |
| ------- | ---------- |
| グローバル   | ログイン〜ログアウト |
| 画面      | 画面表示中      |
| コンポーネント | マウント中      |
| サーバ     | キャッシュ期限まで  |

👉 **寿命が違うものを混ぜると破綻**

---

## 4. 状態管理の設計原則（超重要）

### 原則①「最も狭いスコープで持つ」

* グローバルに置きすぎない
* props → local → global の順で検討

### 原則②「派生状態を持たない」

❌ `total = price * count` をstateに持つ
⭕ 計算で求める（selector）

### 原則③「真実の源（Single Source of Truth）」

* 同じ情報を複数箇所に持たない

### 原則④「状態と振る舞いを分離」

* state（データ）
* action / effect（変更手段）

---

## 5. 状態管理設計の手順（設計工程）

### Step 1：状態洗い出し

画面設計書から状態を列挙

例：

* ユーザー一覧
* 検索条件
* ローディング
* エラー

---

### Step 2：分類・配置決定

| 状態       | 分類      | 管理場所        |
| -------- | ------- | ----------- |
| ログインユーザー | グローバル   | Store       |
| 検索条件     | 画面      | URL / Store |
| モーダル     | コンポーネント | useState    |
| 一覧       | サーバ     | Query Cache |

---

### Step 3：更新トリガー定義

| 状態     | 変更契機       |
| ------ | ---------- |
| 検索条件   | 入力 / URL変更 |
| 一覧     | APIレスポンス   |
| ローディング | API開始/終了   |

---

### Step 4：永続化設計

* リロード耐性が必要か？
* URL / Storage / Cookie？

---

## 6. サーバ状態管理（超重要）

### 6.1 なぜサーバ状態は分離するのか

* キャッシュ
* 再取得
* 再試行
* ローディング制御

👉 **ReduxでAPI結果を管理するのは古い**

---

### 6.2 サーバ状態管理ツール

* React Query / TanStack Query
* SWR

#### サーバ状態の特徴

| 特徴  | 内容         |
| --- | ---------- |
| 非同期 | API依存      |
| 不確定 | 常に最新とは限らない |
| 共有  | 複数画面で使用    |

---

## 7. グローバル状態管理

### 7.1 何を置くべきか

⭕ 認証情報（ユーザーID、権限）
⭕ UIテーマ
❌ APIレスポンス
❌ 一時的な入力値

---

### 7.2 ツール選定指針

| ツール           | 特徴   | 業務向け評価 |
| ------------- | ---- | ------ |
| Redux Toolkit | 厳格   | ◎（大規模） |
| Zustand       | 軽量   | ◎      |
| Recoil        | 柔軟   | ○      |
| Vuex / Pinia  | Vue用 | ◎      |

---

## 8. URLと状態管理（非常に重要）

### URLは「状態」

* 検索条件
* ページ番号
* タブ

例：

```
/users?page=2&role=admin
```

👉 **URLを状態に含めるとリロード耐性が生まれる**

---

## 9. 状態遷移設計（ステートマシン的思考）

例：一覧画面

```
Idle
 ↓ (検索)
Loading
 ↓ (成功)
Success
 ↓ (失敗)
Error
```

👉 複雑な画面は **状態遷移図を描く**

---

## 10. 実装パターン（React例・概念）

```ts
// グローバル状態
const useAuthStore = create((set) => ({
  user: null,
  login: (user) => set({ user }),
  logout: () => set({ user: null }),
}));
```

```ts
// サーバ状態
const { data, isLoading, error } = useQuery({
  queryKey: ['users', condition],
  queryFn: fetchUsers,
});
```

---

## 11. よくある失敗パターン

| 失敗          | なぜダメか    |
| ----------- | -------- |
| 全部Redux     | 肥大化      |
| API結果をstate | キャッシュ地獄  |
| 状態の重複       | 不整合      |
| 永続化しすぎ      | セキュリティ事故 |

---

## 12. 成果物（設計書）

* 状態一覧表（分類付き）
* 状態配置図
* 状態遷移図
* Store設計書
* URL状態設計書

---

### まとめ（重要ポイント）

* 状態管理は「設計」
* 分類と寿命が全て
* サーバ状態は専用管理
* URLを味方にする
* グローバルは最小限

---
